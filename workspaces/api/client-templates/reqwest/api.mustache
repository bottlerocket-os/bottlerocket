{{>partial_header}}
use std::rc::Rc;
use std::borrow::Borrow;

use apiserver::model;

use super::{Error, configuration, urlencode};

pub struct {{{classname}}}Client {
    configuration: Rc<configuration::Configuration>,
}

impl {{{classname}}}Client {
    pub fn new(configuration: Rc<configuration::Configuration>) -> {{{classname}}}Client {
        {{{classname}}}Client {
            configuration: configuration,
        }
    }
}

pub trait {{{classname}}} {
{{#operations}}
{{#operation}}
    fn {{{operationId}}}(&self, {{#allParams}}{{{paramName}}}: {{^required}}Option<{{/required}}{{#isString}}&str{{/isString}}{{#isUuid}}&str{{/isUuid}}{{^isString}}{{^isUuid}}{{^isPrimitiveType}}{{^isContainer}}model::{{/isContainer}}{{/isPrimitiveType}}{{{dataType}}}{{/isUuid}}{{/isString}}{{^required}}>{{/required}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) -> Result<{{^returnType}}(){{/returnType}}{{#returnType}}{{{returnType}}}{{/returnType}}, Error>;
{{/operation}}
{{/operations}}
}

impl {{{classname}}} for {{{classname}}}Client {
{{#operations}}
{{#operation}}
    fn {{{operationId}}}(&self, {{#allParams}}{{{paramName}}}: {{^required}}Option<{{/required}}{{#isString}}&str{{/isString}}{{#isUuid}}&str{{/isUuid}}{{^isString}}{{^isUuid}}{{^isPrimitiveType}}{{^isContainer}}model::{{/isContainer}}{{/isPrimitiveType}}{{{dataType}}}{{/isUuid}}{{/isString}}{{^required}}>{{/required}}{{#hasMore}}, {{/hasMore}}{{/allParams}}) -> Result<{{^returnType}}(){{/returnType}}{{#returnType}}{{{returnType}}}{{/returnType}}, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}{{{path}}}", configuration.base_path{{#pathParams}}, {{{baseName}}}={{#isString}}urlencode({{/isString}}{{{paramName}}}{{#isListContainer}}.join(",").as_ref(){{/isListContainer}}{{#isString}}){{/isString}}{{/pathParams}});
        let mut req_builder = client.{{{httpMethod}}}(uri_str.as_str());

        {{#queryParams}}
        {{^required}}
        if let Some(params) = {{{paramName}}} {
            // The `query` method appends and does NOT overwrite so we can call this multiple times
            req_builder = req_builder.query(&[("{{{baseName}}}", &params{{#isListContainer}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/isListContainer}}.to_string())]);
        }
        {{/required}}
        {{#required}}
        // The `query` method appends and does NOT overwrite so we can call this multiple times
        req_builder = req_builder.query(&[("{{{baseName}}}", &{{{paramName}}}{{#isListContainer}}.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(","){{/isListContainer}}.to_string())]);
        {{/required}}
        {{/queryParams}}
        {{#hasBodyParam}}
        {{#bodyParams}}
        req_builder = req_builder.json(&{{{paramName}}});
        {{/bodyParams}}
        {{/hasBodyParam}}

        // build request
        let req = req_builder.build()?;

        {{^returnType}}
        client.execute(req)?.error_for_status()?;
        Ok(())
        {{/returnType}}
        {{#returnType}}
        Ok(client.execute(req)?.error_for_status()?.json()?)
        {{/returnType}}
    }

{{/operation}}
{{/operations}}
}
