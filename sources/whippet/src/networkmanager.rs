use serde::Deserialize;
use zbus::{dbus_proxy, Result};

/// Generates a Zbus Proxy via a macro that assists in handling calls we might need to the network1 service
///
/// network1 is the service that networkd will emit changes for devices. This service is on the system bus so
/// a connection the system bus is required.
///
/// This was generated by running busctl --system --xml-interface introspect org.freedesktop.network1 /org/freedesktop/network1
/// and passing that input into zbus-xmlgen. This will generate all functions it can find but only the required functions are
/// included below. Most of the functions generated by this tool have been dropped since only a few read-only methods are needed
/// for now.
#[dbus_proxy(
    default_service = "org.freedesktop.network1",
    interface = "org.freedesktop.network1.Manager",
    default_path = "/org/freedesktop/network1",
    assume_defaults = false
)]
trait NetworkManager {
    #[dbus_proxy(object = "Client")]
    fn get_client(&self);

    /// ListLinks method which returns the link index, name, and Zbus specific path to the link
    fn list_links(&self) -> zbus::Result<Vec<(i32, String, zbus::zvariant::OwnedObjectPath)>>;

    /// DescribeLink method returns a JSON string of all the attributes of a link
    fn describe_link(&self, ifindex: i32) -> zbus::Result<String>;

    /// Describe method
    fn describe(&self) -> zbus::Result<String>;

    /// GetLinkByIndex method
    fn get_link_by_index(
        &self,
        ifindex: i32,
    ) -> zbus::Result<(String, zbus::zvariant::OwnedObjectPath)>;

    /// GetLinkByName method
    fn get_link_by_name(&self, name: &str) -> zbus::Result<(i32, zbus::zvariant::OwnedObjectPath)>;

    /// AddressState property
    #[dbus_proxy(property)]
    fn address_state(&self) -> zbus::Result<String>;

    /// CarrierState property
    #[dbus_proxy(property)]
    fn carrier_state(&self) -> zbus::Result<String>;

    /// IPv4AddressState property
    #[dbus_proxy(property, name = "IPv4AddressState")]
    fn ipv4_address_state(&self) -> zbus::Result<String>;

    /// IPv6AddressState property
    #[dbus_proxy(property, name = "IPv6AddressState")]
    fn ipv6_address_state(&self) -> zbus::Result<String>;

    /// OnlineState property
    #[dbus_proxy(property)]
    fn online_state(&self) -> zbus::Result<String>;

    /// OperationalState property
    #[dbus_proxy(property)]
    fn operational_state(&self) -> zbus::Result<String>;
}

#[dbus_proxy(
    default_service = "org.freedesktop.Network1",
    interface = "org.freedesktop.Network1.Client"
)]
trait Client {
    fn start(&self) -> Result<()>;
    fn stop(&self) -> Result<()>;

    #[dbus_proxy(property)]
    fn set_desktop_id(&mut self, id: &str) -> Result<()>;
}

/// LinkState is a minimal struct to contain the output from Zbus describe_link
#[derive(Clone, Debug, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub(crate) struct LinkState {
    pub(crate) name: String,
    pub(crate) administrative_state: String,
}
