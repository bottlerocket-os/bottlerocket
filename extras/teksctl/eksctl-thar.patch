From bbdefa6e4581b738a93ba813e76eaf2a243c98bb Mon Sep 17 00:00:00 2001
From: Jacob Vallejo <jake@jahkeup.com>
Date: Mon, 25 Nov 2019 13:44:25 -0800
Subject: [PATCH 1/3] thar: wire up thar launches

---
 go.mod                        |  2 +-
 pkg/ami/resolver.go           |  3 +-
 pkg/ctl/create/cluster.go     |  2 ++
 pkg/ctl/create/nodegroup.go   |  2 ++
 pkg/nodebootstrap/userdata.go |  4 +++
 pkg/thar/const.go             |  5 ++++
 pkg/thar/flags.go             | 16 +++++++++++
 pkg/thar/images_static.go     | 30 ++++++++++++++++++++
 pkg/thar/resolver.go          | 25 +++++++++++++++++
 pkg/thar/userdata.go          | 53 +++++++++++++++++++++++++++++++++++
 10 files changed, 140 insertions(+), 2 deletions(-)
 create mode 100644 pkg/thar/const.go
 create mode 100644 pkg/thar/flags.go
 create mode 100644 pkg/thar/images_static.go
 create mode 100644 pkg/thar/resolver.go
 create mode 100644 pkg/thar/userdata.go

diff --git a/go.mod b/go.mod
index 974ea723..09f8807d 100644
--- a/go.mod
+++ b/go.mod
@@ -51,7 +51,7 @@ require (
 	github.com/miekg/coredns v0.0.0-20170910182647-1b60688dc8f7 // indirect
 	github.com/onsi/ginkgo v1.10.1
 	github.com/onsi/gomega v1.7.0
-	github.com/pelletier/go-toml v1.4.0 // indirect
+	github.com/pelletier/go-toml v1.4.0
 	github.com/peterbourgon/diskv v2.0.1+incompatible // indirect
 	github.com/pkg/errors v0.8.1
 	github.com/pkg/sftp v1.8.3 // indirect
diff --git a/pkg/ami/resolver.go b/pkg/ami/resolver.go
index 346a14c6..c03cb830 100644
--- a/pkg/ami/resolver.go
+++ b/pkg/ami/resolver.go
@@ -3,6 +3,7 @@ package ami
 import (
 	"github.com/aws/aws-sdk-go/service/ec2/ec2iface"
 	"github.com/aws/aws-sdk-go/service/ssm/ssmiface"
+	"github.com/weaveworks/eksctl/pkg/thar"
 )
 
 // MultiResolver is a Resolver that delegates to one or more Resolvers.
@@ -37,7 +38,7 @@ type Resolver interface {
 // NewDefaultResolver returns a static resolver that delegates on StaticGPUResolver and StaticDefaultResolver
 func NewDefaultResolver() Resolver {
 	return &MultiResolver{
-		delegates: []Resolver{&StaticGPUResolver{}, &StaticDefaultResolver{}},
+		delegates: []Resolver{&StaticGPUResolver{}, thar.NewImageResolver(), &StaticDefaultResolver{}},
 	}
 }
 
diff --git a/pkg/ctl/create/cluster.go b/pkg/ctl/create/cluster.go
index b255584b..da4ea956 100644
--- a/pkg/ctl/create/cluster.go
+++ b/pkg/ctl/create/cluster.go
@@ -16,6 +16,7 @@ import (
 	"github.com/weaveworks/eksctl/pkg/ctl/cmdutils"
 	"github.com/weaveworks/eksctl/pkg/kops"
 	"github.com/weaveworks/eksctl/pkg/printers"
+	"github.com/weaveworks/eksctl/pkg/thar"
 	"github.com/weaveworks/eksctl/pkg/utils"
 	"github.com/weaveworks/eksctl/pkg/utils/kubeconfig"
 	"github.com/weaveworks/eksctl/pkg/utils/names"
@@ -56,6 +57,7 @@ func createClusterCmd(cmd *cmdutils.Cmd) {
 		fs.StringVar(&ng.Name, "nodegroup-name", "", fmt.Sprintf("name of the nodegroup (generated if unspecified, e.g. %q)", exampleNodeGroupName))
 		fs.BoolVar(&params.WithoutNodeGroup, "without-nodegroup", false, "if set, initial nodegroup will not be created")
 		cmdutils.AddCommonCreateNodeGroupFlags(fs, cmd, ng)
+		thar.AddCreateNodeGroupFlags(fs)
 	})
 
 	cmd.FlagSetGroup.InFlagSet("Cluster and nodegroup add-ons", func(fs *pflag.FlagSet) {
diff --git a/pkg/ctl/create/nodegroup.go b/pkg/ctl/create/nodegroup.go
index bafc8f95..d7e15494 100644
--- a/pkg/ctl/create/nodegroup.go
+++ b/pkg/ctl/create/nodegroup.go
@@ -16,6 +16,7 @@ import (
 	"github.com/weaveworks/eksctl/pkg/authconfigmap"
 	"github.com/weaveworks/eksctl/pkg/ctl/cmdutils"
 	"github.com/weaveworks/eksctl/pkg/printers"
+	"github.com/weaveworks/eksctl/pkg/thar"
 	"github.com/weaveworks/eksctl/pkg/utils"
 )
 
@@ -56,6 +57,7 @@ func createNodeGroupCmd(cmd *cmdutils.Cmd) {
 		fs.StringVarP(&ng.Name, "name", "n", "", fmt.Sprintf("name of the new nodegroup (generated if unspecified, e.g. %q)", exampleNodeGroupName))
 		cmdutils.AddCommonCreateNodeGroupFlags(fs, cmd, ng)
 		fs.BoolVarP(&params.managed, "managed", "", false, "Create EKS-managed nodegroup")
+		thar.AddCreateNodeGroupFlags(fs)
 	})
 
 	cmd.FlagSetGroup.InFlagSet("IAM addons", func(fs *pflag.FlagSet) {
diff --git a/pkg/nodebootstrap/userdata.go b/pkg/nodebootstrap/userdata.go
index b1d6e81f..a2f3428c 100644
--- a/pkg/nodebootstrap/userdata.go
+++ b/pkg/nodebootstrap/userdata.go
@@ -13,6 +13,8 @@ import (
 	api "github.com/weaveworks/eksctl/pkg/apis/eksctl.io/v1alpha5"
 	"github.com/weaveworks/eksctl/pkg/cloudconfig"
 	"github.com/weaveworks/eksctl/pkg/utils/kubeconfig"
+
+	"github.com/weaveworks/eksctl/pkg/thar"
 )
 
 //go:generate ${GOBIN}/go-bindata -pkg ${GOPACKAGE} -prefix assets -nometadata -o assets.go assets
@@ -183,6 +185,8 @@ func NewUserData(spec *api.ClusterConfig, ng *api.NodeGroup) (string, error) {
 		return NewUserDataForUbuntu1804(spec, ng)
 	case api.NodeImageFamilyWindowsServer2019FullContainer, api.NodeImageFamilyWindowsServer2019CoreContainer:
 		return newUserDataForWindows(spec, ng)
+	case thar.NodeImageFamilyThar:
+		return thar.NewUserDataForThar(spec, ng)
 	default:
 		return "", nil
 	}
diff --git a/pkg/thar/const.go b/pkg/thar/const.go
new file mode 100644
index 00000000..1a6c89f5
--- /dev/null
+++ b/pkg/thar/const.go
@@ -0,0 +1,5 @@
+package thar
+
+const (
+	NodeImageFamilyThar = "thar"
+)
diff --git a/pkg/thar/flags.go b/pkg/thar/flags.go
new file mode 100644
index 00000000..823a3a14
--- /dev/null
+++ b/pkg/thar/flags.go
@@ -0,0 +1,16 @@
+package thar
+
+import "github.com/spf13/pflag"
+
+var (
+	flagEnableAdminContainer bool    = true
+	flagBaseTOMLFile         string  = ""
+	flagTharImageVersion     imageID = defaultTharImageVersion
+)
+
+// AddCreateNodeGroupFlags appends thar related flags to the command's flagset.
+func AddCreateNodeGroupFlags(fs *pflag.FlagSet) {
+	fs.BoolVar(&flagEnableAdminContainer, "node-admin-container", flagEnableAdminContainer, "Enable the Thar Admin container")
+	fs.StringVar(&flagBaseTOMLFile, "node-settings-toml", flagBaseTOMLFile, "Provide a base settings.toml userdata for NodeGroup")
+	fs.StringVar(&flagTharImageVersion, "node-image-version", flagTharImageVersion, "Thar image version (advanced usage)")
+}
diff --git a/pkg/thar/images_static.go b/pkg/thar/images_static.go
new file mode 100644
index 00000000..ed3b4f44
--- /dev/null
+++ b/pkg/thar/images_static.go
@@ -0,0 +1,30 @@
+package thar
+
+type imageID = string
+type versionID = string
+type regionID = string
+
+type regionalListing = map[regionID]imageID
+
+// version in this case *is not* kubernetes, it's thar.
+type versionListing = map[versionID]regionalListing
+
+const (
+	defaultTharImageVersion = "0.1.6"
+)
+
+var staticImages = versionListing{
+	"0.1.6": regionalListing{
+		"us-west-2": "ami-07245e9300b9290c1",
+		"us-east-1": "ami-02a409074bbecb641",
+	},
+	"0.1.5": regionalListing{
+		"us-west-2": "ami-0b00816dd82d05e1f",
+	},
+	"0.1.4": regionalListing{
+		"us-west-2": "ami-0331423be16b32cca",
+	},
+	"0.1.3": regionalListing{
+		"us-west-2": "ami-0346bb6ef129f9f11",
+	},
+}
diff --git a/pkg/thar/resolver.go b/pkg/thar/resolver.go
new file mode 100644
index 00000000..62c46cbf
--- /dev/null
+++ b/pkg/thar/resolver.go
@@ -0,0 +1,25 @@
+package thar
+
+import "errors"
+
+type imageResolver struct{}
+
+func NewImageResolver() *imageResolver {
+	return &imageResolver{}
+}
+
+func (*imageResolver) Resolve(region, _kubeVersion, _instanceType, imageFamily string) (string, error) {
+	if imageFamily != NodeImageFamilyThar {
+		return "", nil
+	}
+	return resolveTharImage(flagTharImageVersion, region)
+}
+
+func resolveTharImage(version versionID, region regionID) (string, error) {
+	if byRegion, ok := staticImages[version]; ok {
+		if image, ok := byRegion[region]; ok {
+			return image, nil
+		}
+	}
+	return "", errors.New("unknown image by region and version")
+}
diff --git a/pkg/thar/userdata.go b/pkg/thar/userdata.go
new file mode 100644
index 00000000..b0df3ccc
--- /dev/null
+++ b/pkg/thar/userdata.go
@@ -0,0 +1,53 @@
+package thar
+
+import (
+	"encoding/base64"
+
+	toml "github.com/pelletier/go-toml"
+	api "github.com/weaveworks/eksctl/pkg/apis/eksctl.io/v1alpha5"
+)
+
+// NewUserDataForThar generates TOML userdata for bootstrapping a Thar node.
+func NewUserDataForThar(spec *api.ClusterConfig, ng *api.NodeGroup) (string, error) {
+	var (
+		baseTOML *toml.Tree
+		tomlErr  error
+	)
+	if flagBaseTOMLFile != "" {
+		baseTOML, tomlErr = toml.LoadFile(flagBaseTOMLFile)
+	} else {
+		baseTOML, tomlErr = toml.Load("")
+	}
+	if tomlErr != nil {
+		return "", tomlErr
+	}
+
+	return NewUserDataForTharWithBase(spec, ng, baseTOML)
+}
+
+// NewUserDataForThar generates TOML userdata for bootstrapping a Thar node.
+// Additional settings may be provided by supplying a base TOML file to write
+// with.
+func NewUserDataForTharWithBase(spec *api.ClusterConfig, ng *api.NodeGroup, baseTOML *toml.Tree) (string, error) {
+	tree := baseTOML
+	// TODO: check keys prior to use, they're quietly overridden.
+
+	// Make EKS relevant settings overriding anything in the base toml (if it
+	// was provided).
+	tree.SetWithComment("settings.kubernetes.cluster-certificate", "Kubernetes Cluster CA Certificate",
+		false, // insert without commenting it out
+		base64.StdEncoding.EncodeToString([]byte(spec.Status.CertificateAuthorityData)))
+	tree.SetWithComment("settings.kubernetes.api-server", "Kubernetes Control Plane API Endpoint",
+		false, // insert without commenting it out
+		spec.Status.Endpoint)
+	tree.SetWithComment("settings.kubernetes.cluster-name", "Kubernetes Cluster Name",
+		false, // insert without commenting it out
+		spec.Metadata.Name)
+	tree.SetWithComment("settings.host-containers.admin.enabled", "Thar Admin Container",
+		false, // insert without commenting it out
+		flagEnableAdminContainer)
+
+	userdata := base64.StdEncoding.EncodeToString([]byte(tree.String()))
+
+	return userdata, nil
+}
-- 
2.25.0


From 88956c9234b17eba49fd05e4d7fcdd9c282a37ab Mon Sep 17 00:00:00 2001
From: Jacob Vallejo <jake@jahkeup.com>
Date: Mon, 25 Nov 2019 18:13:20 -0800
Subject: [PATCH 2/3] thar: add validation at beginning

Without this, errors would not be discovered until much later in the
cluster creation process. This uses a hack where the validation logic is
applied at image retrieval time because adding it to the CLI flow seemed
intrusive at the time. It very much should be revisited.
---
 pkg/ctl/create/cluster.go   |  3 ++-
 pkg/ctl/create/nodegroup.go |  3 ++-
 pkg/thar/flags.go           | 23 ++++++++++++++++++++++-
 pkg/thar/resolver.go        |  9 ++++++++-
 4 files changed, 34 insertions(+), 4 deletions(-)

diff --git a/pkg/ctl/create/cluster.go b/pkg/ctl/create/cluster.go
index da4ea956..a5cb0e3c 100644
--- a/pkg/ctl/create/cluster.go
+++ b/pkg/ctl/create/cluster.go
@@ -57,9 +57,10 @@ func createClusterCmd(cmd *cmdutils.Cmd) {
 		fs.StringVar(&ng.Name, "nodegroup-name", "", fmt.Sprintf("name of the nodegroup (generated if unspecified, e.g. %q)", exampleNodeGroupName))
 		fs.BoolVar(&params.WithoutNodeGroup, "without-nodegroup", false, "if set, initial nodegroup will not be created")
 		cmdutils.AddCommonCreateNodeGroupFlags(fs, cmd, ng)
-		thar.AddCreateNodeGroupFlags(fs)
 	})
 
+	cmd.FlagSetGroup.InFlagSet("Initial nodegroup (node-ami-family: thar)", thar.AddCreateNodeGroupFlags)
+
 	cmd.FlagSetGroup.InFlagSet("Cluster and nodegroup add-ons", func(fs *pflag.FlagSet) {
 		cmdutils.AddCommonCreateNodeGroupIAMAddonsFlags(fs, ng)
 	})
diff --git a/pkg/ctl/create/nodegroup.go b/pkg/ctl/create/nodegroup.go
index d7e15494..b88eead2 100644
--- a/pkg/ctl/create/nodegroup.go
+++ b/pkg/ctl/create/nodegroup.go
@@ -57,9 +57,10 @@ func createNodeGroupCmd(cmd *cmdutils.Cmd) {
 		fs.StringVarP(&ng.Name, "name", "n", "", fmt.Sprintf("name of the new nodegroup (generated if unspecified, e.g. %q)", exampleNodeGroupName))
 		cmdutils.AddCommonCreateNodeGroupFlags(fs, cmd, ng)
 		fs.BoolVarP(&params.managed, "managed", "", false, "Create EKS-managed nodegroup")
-		thar.AddCreateNodeGroupFlags(fs)
 	})
 
+	cmd.FlagSetGroup.InFlagSet("New nodegroup (node-ami-family: thar)", thar.AddCreateNodeGroupFlags)
+
 	cmd.FlagSetGroup.InFlagSet("IAM addons", func(fs *pflag.FlagSet) {
 		cmdutils.AddCommonCreateNodeGroupIAMAddonsFlags(fs, ng)
 	})
diff --git a/pkg/thar/flags.go b/pkg/thar/flags.go
index 823a3a14..32a78c39 100644
--- a/pkg/thar/flags.go
+++ b/pkg/thar/flags.go
@@ -1,6 +1,12 @@
 package thar
 
-import "github.com/spf13/pflag"
+import (
+	"os"
+
+	toml "github.com/pelletier/go-toml"
+	"github.com/pkg/errors"
+	"github.com/spf13/pflag"
+)
 
 var (
 	flagEnableAdminContainer bool    = true
@@ -14,3 +20,18 @@ func AddCreateNodeGroupFlags(fs *pflag.FlagSet) {
 	fs.StringVar(&flagBaseTOMLFile, "node-settings-toml", flagBaseTOMLFile, "Provide a base settings.toml userdata for NodeGroup")
 	fs.StringVar(&flagTharImageVersion, "node-image-version", flagTharImageVersion, "Thar image version (advanced usage)")
 }
+
+func validateFlagArgs() error {
+	if flagBaseTOMLFile != "" {
+		_, fileErr := os.Stat(flagBaseTOMLFile)
+		if fileErr != nil {
+			return errors.Wrapf(fileErr, "cannot use provided file %q", flagBaseTOMLFile)
+		}
+		_, loadErr := toml.LoadFile(flagBaseTOMLFile)
+		if loadErr != nil {
+			return errors.Wrapf(loadErr, "TOML error in provided file %q", flagBaseTOMLFile)
+		}
+	}
+
+	return nil
+}
diff --git a/pkg/thar/resolver.go b/pkg/thar/resolver.go
index 62c46cbf..f2cfcb3f 100644
--- a/pkg/thar/resolver.go
+++ b/pkg/thar/resolver.go
@@ -1,6 +1,6 @@
 package thar
 
-import "errors"
+import "github.com/pkg/errors"
 
 type imageResolver struct{}
 
@@ -12,6 +12,13 @@ func (*imageResolver) Resolve(region, _kubeVersion, _instanceType, imageFamily s
 	if imageFamily != NodeImageFamilyThar {
 		return "", nil
 	}
+
+	// HACK: edit to command level validation is intrusive, so we do it here.
+	validationErr := validateFlagArgs()
+	if validationErr != nil {
+		return "", validationErr
+	}
+
 	return resolveTharImage(flagTharImageVersion, region)
 }
 
-- 
2.25.0


From 85fca72b71d23bd5b15431ff08ce09be0dec31fb Mon Sep 17 00:00:00 2001
From: Jacob Vallejo <jake@jahkeup.com>
Date: Wed, 27 Nov 2019 12:14:06 -0800
Subject: [PATCH 3/3] thar: update aws-node during cluster setup

---
 pkg/ctl/create/cluster.go     | 10 ++++++++++
 pkg/thar/check.go             | 12 ++++++++++++
 pkg/thar/cluster/configure.go | 22 ++++++++++++++++++++++
 3 files changed, 44 insertions(+)
 create mode 100644 pkg/thar/check.go
 create mode 100644 pkg/thar/cluster/configure.go

diff --git a/pkg/ctl/create/cluster.go b/pkg/ctl/create/cluster.go
index a5cb0e3c..9a847f67 100644
--- a/pkg/ctl/create/cluster.go
+++ b/pkg/ctl/create/cluster.go
@@ -17,6 +17,7 @@ import (
 	"github.com/weaveworks/eksctl/pkg/kops"
 	"github.com/weaveworks/eksctl/pkg/printers"
 	"github.com/weaveworks/eksctl/pkg/thar"
+	tharcl "github.com/weaveworks/eksctl/pkg/thar/cluster"
 	"github.com/weaveworks/eksctl/pkg/utils"
 	"github.com/weaveworks/eksctl/pkg/utils/kubeconfig"
 	"github.com/weaveworks/eksctl/pkg/utils/names"
@@ -355,6 +356,15 @@ func doCreateCluster(cmd *cmdutils.Cmd, ng *api.NodeGroup, params *cmdutils.Crea
 			return err
 		}
 
+		// TODO: refactor AMI Families with interfaces for additional setup steps.
+		if thar.InNodeGroups(cfg.NodeGroups...) {
+			logger.Info("Configuring cluster for Thar nodes")
+			err := tharcl.Configure(cfg, ctl)
+			if err != nil {
+				return err
+			}
+		}
+
 		for _, ng := range cfg.NodeGroups {
 			// authorise nodes to join
 			if err = authconfigmap.AddNodeGroup(clientSet, ng); err != nil {
diff --git a/pkg/thar/check.go b/pkg/thar/check.go
new file mode 100644
index 00000000..66b3dc91
--- /dev/null
+++ b/pkg/thar/check.go
@@ -0,0 +1,12 @@
+package thar
+
+import api "github.com/weaveworks/eksctl/pkg/apis/eksctl.io/v1alpha5"
+
+func InNodeGroups(ngs ...*api.NodeGroup) bool {
+	for _, ng := range ngs {
+		if ng.AMIFamily == NodeImageFamilyThar {
+			return true
+		}
+	}
+	return false
+}
diff --git a/pkg/thar/cluster/configure.go b/pkg/thar/cluster/configure.go
new file mode 100644
index 00000000..e1ce19fa
--- /dev/null
+++ b/pkg/thar/cluster/configure.go
@@ -0,0 +1,22 @@
+package cluster
+
+import (
+	"github.com/weaveworks/eksctl/pkg/addons/default"
+	api "github.com/weaveworks/eksctl/pkg/apis/eksctl.io/v1alpha5"
+	"github.com/weaveworks/eksctl/pkg/eks"
+)
+
+// Configure tunes a cluster for running Thar nodes.
+func Configure(cfg *api.ClusterConfig, provider *eks.ClusterProvider) error {
+	rawClient, err := provider.NewRawClient(cfg)
+	if err != nil {
+		return err
+	}
+
+	_, err = defaultaddons.UpdateAWSNode(rawClient, cfg.Metadata.Region, false)
+	if err != nil {
+		return err
+	}
+
+	return nil
+}
-- 
2.25.0

